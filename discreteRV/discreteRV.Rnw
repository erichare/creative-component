\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{RJournal}
\usepackage{amsmath,amssymb,array,float}
\usepackage{booktabs}

\newcommand{\hh}[1]{{\color{magenta} #1}} 

%% load any required packages here

\begin{document}

%% do not edit, for illustration only
\sectionhead{Contributed research article}
\volume{XX}
\volnumber{YY}
\year{2014}
\month{AAAA}

%% replace RJtemplate with your article
\begin{article}

\title{Manipulation of Discrete Random Variables with discreteRV}
\author{by Eric Riemer Hare, Andreas Buja, and Heike Hofmann}

\maketitle

\abstract{
A major issue in statistics education is the sometimes large disparity between the mathematical and theoretical coursework, and the computational coursework. \pkg{discreteRV} is an R package for manipulation of discrete random variables which uses clean and familiar syntax similar to that which is found in introductory probability courses. It is simple enough for those less experienced with statistical programming, but has more advanced features which are suitable for a large number of more complex applications. In this paper, I introduce and motivate \pkg{discreteRV}, describe its functionality, and provide reproducible examples illustrating its use.
}

<<concordance, echo=FALSE>>=
    opts_chunk$set(concordance=TRUE, fig.width=4, fig.height=4)
    opts_knit$set(self.contained=FALSE)
@

<<libraries, echo=FALSE, cache=FALSE, message=FALSE>>=
    #library(devtools)

    #install_github("discreteRV", "erichare")

    suppressWarnings(library(discreteRV))
    library(MASS)
@

\section{Introduction}

One of the primary hurdles in teaching probability courses in an undergraduate setting is the missing link between theoretical statements from textbooks and lectures, and the notation used in statistical software required in more and more classes. Depending on the background of the student, this missing link can manifest itself in a couple of different ways. Some students will master the theoretical concepts and notation, but struggle in a computing environment. Others will feel very comfortable with statistical programming, but sometimes struggle to translate that back to the classroom probability setting.

\pkg{discreteRV} is an attempt to bridge this gap. It provides a comprehensive set of functions to create, manipulate, and simulate from discrete random variables. \pkg{discreteRV} is designed for introductory probability courses. It uses syntax which in most cases closely matches probability textbooks to allow for a more seamless connection between a probability classroom setting and the use of statistical software. \pkg{discreteRV} is available for download on the Comprehensive R Archive Network (CRAN).

The functions of \pkg{discreteRV} are organized into two logical areas, termed probabilities and simulations.

\section{Probabilities}

\pkg{discreteRV} includes a suite of functions to create, manipulate, and compute distributional quantities for discrete random variables. A list of these functions and brief discriptions of their functionality is available in Table \ref{tbl:discreteRV-probs}.

\begin{table}
\centering
\scalebox{0.95}{
\begin{tabular}{lp{0.8\textwidth}}\hline
Name & Description \\ 
\hline
Creation \\ 
\hline
\code{as.RV} & Turn a probability vector with possible outcome values in the names() attribute into a random variable \\
\code{make.RV} & Make a random variable consisting of possible outcome values and their probabilities or odds \\
\hline
Manipulation \\ 
\hline
\code{margins} & Marginal distribution of a joint random variable \\
\code{mult} & Joint probability mass function of random variables X and Y \\
\code{multN} & Probability mass function of $X^n$ \\
\code{SofI} & Sum of independent random variables \\
\code{SofIID} & Sum of independent identically distributed random variables \\
\hline
Probabilities \\ 
\hline
\code{E} & Expected value of a random variable \\
\code{KURT} & Kurtosis of a random variable \\
\code{P} & Calculate probabilities of events \\
\code{probs} & Probability mass function of random variable X \\
\code{SD} & Standard deviation of a random variable \\
\code{SKEW} & Skewness of a random variable \\
\code{V} & Variance of a random variable \\
\hline
Methods \\
\hline 
\code{plot.RV} & Plot a random variable of class RV \\
\code{print.RV} & Print a random variable of class RV \\
\code{qqnorm.RV} & Normal quantile plot for RVs to answer the question how close to normal it is \\

\hline
\end{tabular}}
\caption{\label{tbl:discreteRV-probs} Overview of functions provided in \pkg{discreteRV} ordered by topics.}
\end{table}

\subsection{Creating random variables}
The centerpiece of \pkg{discreteRV} is a set of functions to create and manipulate discrete random variables. A random variable $X$ is defined \citep[see e.g.~][]{ws:1999} as a theoretical construct representing the value of an outcome of a random experiment. A discrete random variable is a special case that can only take on a countable set of values. Here, we will make the additional constraint to only allow a finite number of values. In practice, this constraint has minimal impact. Discrete random variables are associated with probability mass functions, which map the set of possible outcomes of the random experiment to probabilities. Probability mass functions must therefore define probabilities which are between zero and one, and must sum to one. 

Throughout this document, we will work with two random variables, a simple example of a discrete random variable representing the value of a roll of a fair die, and  one representing a realization of a Poisson random variable with mean parameter equal to two. Formally, we can define such random variables and their probability mass functions as follows:

Let $X$ be a random variable representing a single roll of a fair die; i.e., the sample space $\Omega = \{1, 2, 3, 4, 5, 6\}$ and $X$ is the identity, mapping the upturned face of a die roll to the corresponding number of dots visible. Then,

\begin{displaymath}
   f(x) = P(X = x) = \left\{
     \begin{array}{lr}
       \frac{1}{6} & x \in {1, 2, 3, 4, 5, 6}\\
       0 & \text{otherwise}
     \end{array}
   \right.
\end{displaymath} \\

Let $Y$ be a random variable distributed according to a Poisson distribution with mean parameter $\lambda$. In this case, the sample space $\Omega = \{0, 1, 2, ... \}$ (the non-negative integers). Then,

\begin{displaymath}
   f(y) = P(Y = y) = \left\{
     \begin{array}{lr}
       \frac{\lambda^y e^{-\lambda}}{y!} & y \in {0, 1, 2, ...}\\
       0 & \text{otherwise}
     \end{array}
   \right.
\end{displaymath} \\

In \pkg{discreteRV}, a discrete random variable is defined through the use of the \code{make.RV} function. \code{make.RV} accepts a vector of outcomes, a vector of probabilities, and returns an \code{RV} object. The code to create X, a random variable representing the roll of a fair die, is as follows:

<<makeRV>>=
X <- make.RV(outcomes = 1:6, probs = 1/6)
X
@

Outcomes can be specified as a range of values, which is useful for distributions in which the outcomes that can occur with non-zero probability are unbounded. This can be indicated with the \code{range} parameter, which defaults to TRUE in the event that the range of values includes positive or negative infinity. To define our poisson random variable Y, we specify the outcomes as a range and the probabilities as a function:

<<makeRVpois>>=
pois.func <- function(y, lambda = 2) { return(lambda^y * exp(-lambda) / factorial(y)) }

Y <- make.RV(outcomes = c(0, Inf), probs = pois.func)
Y
@

The make.RV function also allows the definition of a random variable in terms of odds. One can construct a loaded die in which a roll of one is four times as likely as any other roll as:

<<makeRVodds>>=
X.loaded <- make.RV(outcomes = 1:6, odds = c(4, 1, 1, 1, 1, 1))
X.loaded
@

\subsection{Structure of an RV Object}

The syntactic structure of the included functions lends itself both to a natural presentation of elementary probabilities and properties of probability mass functions in an introductory probability course, as well as more advanced modeling of discrete random variables. In Table \ref{tbl:discreteRV-connect}, we provide an overview of the notational similarities between \pkg{discreteRV} and the commonly used probability textbook by \cite{cb:2001}

\begin{table}
\centering
\scalebox{0.95}{
\begin{tabular}{lp{0.8\textwidth}}\hline
discreteRV & Casella and Berger \\ 
\hline
\code{E(X)} & E(X) \\
\code{P(X == x)} & $P(X = x)$ \\
\code{P(X >= x)} & $P(X \ge x)$ \\
\code{P((X < x1) \%AND\% (X > x2))} & $P(X < x_1 \cap X > x_2)$ \\
\code{P((X < x1) \%OR\% (X > x2))} & $P(X < x_1 \cup X > x_2)$ \\
\code{P((X == x1) | (X > x2))} & $P(X < x_1 | X > x_2)$ \\
\code{probs(X)} & $f(x)$ \\
\code{SD(X)} & $sd(X)$ \\
\code{V(X)} & $var(X)$ \\
\end{tabular}}
\caption{\label{tbl:discreteRV-connect} Probability functions in \pkg{discreteRV} and their corresponding syntax in introductory statistics courses.}
\end{table}

A random variable object is constructed by defining a standard R vector to be the possible outcomes that the random variable can take (the sample space $\Omega$). It is preferred, though not required, that these be encoded as integers, since this allows the computation expected values, variances, and other distributional properties. This vector of outcomes then stores attributes which include the probability of each outcome. By default, the print method for a random variable will display the probabilities as fractions in most cases, aiding in readability. The probabilities can be retrieved as a numeric vector by using the \code{probs} function:

<<probs>>=
probs(X)
@

\subsection{Probability-based Calculations}

By storing the outcomes as the principle component of the object X, we can now make a number of probability statements in R. For instance, we can ask what the probability of obtaining a roll greater than 1 is by using the code \code{P(X > 1)}. R will check which values in the vector X are greater than 1. In this case, these are the outcomes 2, 3, 4, 5, and 6. Hence, R will return TRUE for these elements of X, and then we can encode a function P to compute the probability of this occurrence by simply summing over the probability values stored in the names of these particular outcomes. Likewise, we can make slightly more complicated probability statements such as $P(X > 5 \cup X = 1)$, using the \code{\%OR\%} and \code{\%AND\%} operators. Consider our Poisson random variable $Y$, and suppose we want to obtain the probability that $Y$ is with a distance $\delta$ of its mean parameter $\lambda = 2$:

<<poisexample>>=
delta <- 3
lambda <- 2

P((Y >= lambda - delta) %AND% (Y <= lambda + delta))
@

In addition, conditional probabilities are also supported. For instance, to calculate the probability of obtaining a roll of one given that the roll is no more than 3, you would use the code \code{P(X == 1 | X <= 3)}. The use of the pipe operator may be less intuitive to the seasoned R programmer, but overcomes a major notational issue in that conditional probabilities are most commonly specified with the pipe. This issue led to the creation of the \code{\%OR\%} and \code{\%AND\%} operators specified previously.

Several other distributional quantities are computable, including the expected value and the variance of a random variable. As in notation from probability courses, expected values can be found with the \code{E} function. To compute the expected value for a single roll of a fair die, we run the code \code{E(X)}. The expected value for a poisson random variable is its mean, and hence \code{E(Y)} will return two.

\subsection{Joint Distributions}

Aside from moments and probability statements, \pkg{discreteRV} includes a powerful set of functions used to create joint probability distributions. Once again letting X be a random variable representing a single die roll, we can use the \code{multN} function to compute the probability mass function of n trials of X. Table \ref{tbl:fairdiemult} gives the first eight outcomes for $n = 2$, and Table \ref{tbl:fairdiemult3} gives an the first eight outcomes for $n = 3$. Notice again that the probabilities have been coerced into fractions for readability. Notice also that the outcomes are encoded by the outcomes on each trial separated by a period.

<<fairdiemult, echo=FALSE, results='asis', message=FALSE>>=
library(xtable)

XX <- multN(X, fractions = TRUE)
print(xtable(t(data.frame(Outcome = as.character(XX), Probability = as.character(fractions(attr(XX, "probs")))))[,1:8], label = "tbl:fairdiemult", caption = "First eight Outcomes and their associated Probabilities for a variable representing two independent rolls of a die."), table.position = 'H', include.colnames = FALSE)
@

<<fairdiemult3, echo=FALSE, results='asis', message=FALSE>>=
library(xtable)

XX <- multN(X, n = 3, fractions = TRUE)
print(xtable(t(data.frame(Outcome = as.character(XX), Probability = as.character(fractions(attr(XX, "probs")))))[,1:8], label = "tbl:fairdiemult3", caption = "First eight Outcomes and their associated Probabilities for a variable representing three independent rolls of a die."), table.position = 'H', include.colnames = FALSE)
@

\pkg{discreteRV} also includes functions to compute the sum of independent random variables. If the variables are identically distributed, the \code{SofIID} function can be used to compute probabilities for the sum of n independent realizations of the random variable. In our fair die example, \code{SofIID(X, 2)} would create a random variable object with the representation given in Table \ref{tbl:fairdiesofi}

<<fairdiesofi, echo=FALSE, results='asis'>>=
X2 <- SofIID(X, n = 2, fractions = TRUE)
print(xtable(t(data.frame(Outcome = as.character(X2), Probability = as.character(fractions(attr(X2, "probs"))))), label = "tbl:fairdiesofi", caption = "Outcomes and their associated Probabilities for a variable representing the sum of two independent rolls of a die."), table.position = 'H', include.colnames = FALSE)
@

\subsection{Plotting}
\pkg{discreteRV} includes a \code{plot} method for random variable objects so that a visualization of the outcomes and probabilities can be made simply by calling \code{plot(X)}. The result of plotting the random variable representing a fair die is given in Figure \ref{fig:plot1}. The x axis includes all outcomes, and the y axis includes the probabilities of each particular outcome. The result of plotting a random variable representing the sum of two independent rolls of a die is given in Figure \ref{fig:plot2}. The result of plotting a random variable representing the sum of 20 independent rolls of a die is given in Figure \ref{fig:plot20}.

<<plot1, echo=FALSE, fig.cap='Plot method called on a fair die random variable.', fig.align='center', fig.pos='H'>>=
plot(X)
@

<<plot2, echo=FALSE, fig.cap='Plot method called on a sum of two fair die random variables.', fig.align='center', fig.pos='H'>>=
plot(X2)
@

<<plot20, echo=FALSE, fig.cap='Plot method called on a sum of 20 fair die random variables.', fig.align='center', fig.pos='H'>>=
X20 <- SofIID(X, n = 20, progress = FALSE)
plot(X20)
@

In addition to a plotting method, there is also a method for \code{qqnorm} to allow assessment of normality for random variable objects, as displayed in Figure \ref{fig:qqplot}.

<<qqplot, echo=FALSE, fig.cap='qqnorm method called on a sum of 20 fair die random variables.', fig.align='center', fig.pos='H'>>=
qqnorm(X20)
@

\section{Simulation}
\pkg{discreteRV} also includes a set of functions to simulate trials from a random variable. A list of these functions and brief discriptions of their functionality is available in Table \ref{tbl:discreteRV-sim}.

\begin{table}[!h]
\centering
\scalebox{0.95}{
\begin{tabular}{ll}\hline
Name & Description \\
\hline
plot.RVsim & Plot a simulated random vector \\
Prop & Proportion of an event observed in a vector of simulated trials \\
props & Proportions of observed outcomes in one or more vectors of simulated trials \\
rsim & Simulate n independent trials from a random variable X \\
skewSim & Skew of the empirical distribution of simulated data \\
\hline
\end{tabular}}
\caption{\label{tbl:discreteRV-sim} List of the simulation functions contained in \pkg{discreteRV}. }
\end{table}

\subsection{Creation}
Creating a simulated random vector is done by using the \code{rsim} function. \code{rsim} accepts a parameter n representing the number of independent trials to simulate, and a parameter X representing the random variable with which to simulate from. For example, suppose we'd like to simulate ten trials from a fair die. We have already created a random variable object X, so we simply call rsim as follows:

<<rsim>>=
X.sim <- rsim(10, X)
X.sim
@

The object returned is a vector of simulated values, with a class attribute to contain the random variable that was used for the simulation. If we would like to retrieve only the simulated values and exclude the attached probabilities, we can coerce the object into a vector using R's built-in \code{as.vector} function.

<<asvector>>=
as.vector(X.sim)
@

It is also possible to retrieve some quantities from the simulation. We can retrieve the empirical distribution of simulated values with the \code{props} function. This will return the outcomes from the original random variable object, and the observed proportion of simulated values for each of the outcomes. We can also compute observed proportions of events by using the \code{Prop} function. Similar to the \code{P} function for probability computations on random variable objects, \code{Prop} accepts a variety of logical statements.

<<props>>=
props(X.sim)
Prop(X.sim == 3)
Prop(X.sim > 3)
@

\section{Case Study: Playing Craps}
Craps is a common card game played in casinos. The game begins with what is called the ``Come Out" roll, in which two fair dice are rolled. If a sum of seven or eleven is obtained, the player wins. If a sum of two, three, or twelve is obtained, the player loses. In all other cases, the roll obtained is declared the ``Point" and the player rolls again in an attempt to obtain this same point value. If the player rolls the Point, they win, but if they roll a seven, they lose. Rolls continue until one of these two outcomes is achieved.

\pkg{discreteRV} allows for a seamless analysis and simulation of the probabilities associated with different events in Craps. Let us begin by asking ``What is the probability that the game ends after the first roll?" Let us construct random variables to answer this question. We construct a random variable \code{X} representing the single roll of a fair die, and then we use the \code{SofIID} function to sum over two rolls.

<<craps1>>=
X <- make.RV(outcomes = 1:6, probs = 1/6)
X2 <- SofIID(X, n = 2)
X2
@

Recall that the game ends after the first roll if and only if a seven or eleven is obtained (resulting in a win), or a two, three, or twelve is obtained (resulting in a loss). Hence, we calculate the probability that the game ends after the first roll as follows:

<<craps2>>=
win_rolls <- c(7, 11)
loss_rolls <- c(2, 3, 12)

P(X2 %in% c(win_rolls, loss_rolls))
@

Now suppose we would like to condition on the game having ended after the first roll. Using the conditional probability operator in \pkg{discreteRV}, we can obtain the probabilities of winning and losing given that the game ended after the first roll:

<<craps3>>=
P(X2 %in% win_rolls | X2 %in% c(win_rolls, loss_rolls))
P(X2 %in% loss_rolls | X2 %in% c(win_rolls, loss_rolls))
@

Now, let's turn our attention to calculating the probability of winning a game in two rolls. Recall that we can use the \code{multN} function to generate joint distributions of independent and identically distributed random variables. In this case, we would like to generate the joint distribution for two independent rolls of two dice. Now, we will have possible outcomes ($11^2$), and our job is to determine which outcomes result in a win. We know that any time the first roll is a seven or eleven, we will have won. We also know that if the roll is between four and ten inclusive, then we will get to roll again. To win within two rolls given that we've received a four through ten requires that the second roll match the first. We can enumerate the various possibilities to calculate the probability of winning in two rolls:

<<craps4>>=
X22 <- multN(X2, 2)
winning_outcomes <- c(paste(7, 2:12, sep = ","), paste(11, 2:12, sep = ","), paste(4:10, 4:10, sep = ","))
winning_outcomes

P(X22 %in% winning_outcomes)
@

Finally, suppose we are interested in the empirical probability of winning a game of Craps. Using the simulation functions in \pkg{discreteRV}, we can write a routine in order to test this. Using the \code{rsim} function, we simulate a single game of Craps by rolling from our random variable representing the sum of two dice. We simulate 100 games, and then perform this simulation 1000 times:

<<craps5>>=
craps_game <- function(RV) {    
    my.roll <- rsim(1, RV)
    if (my.roll %in% c(7, 11)) {
        return(1)    
    } else if (my.roll %in% c(2, 3, 12)) {
        return(0)
    } else {
        new.roll <- 0
        while (new.roll != my.roll & new.roll != 7) {
            new.roll <- rsim(1, RV)
        }
        
        return(as.numeric(new.roll == my.roll))
    }
}

sim.results <- replicate(1000, sum(replicate(100, craps_game(X2))))
mean(sim.results / 100)
@

\section{Conclusion}
The power of \pkg{discreteRV} is truly in its simplicity. Because it uses familiar introductory probability syntax, it can allow students who may not be experienced or comfortable with programming to ease into computer-based computations. Nonetheless, \pkg{discreteRV} also includes several powerful functions for analyzing, summing, and combining discrete random variables which can be of use to the experienced programmer.

\nocite{*}
\bibliography{references.bib}

\end{article}

\end{document}